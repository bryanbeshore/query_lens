# QueryLens

A mountable Rails engine that lets users write natural language questions and get SQL queries generated by AI, executed against their database, with results displayed — all in one interface. Think "Blazer meets ChatGPT."

Powered by [RubyLLM](https://rubyllm.com), QueryLens works with any major AI provider: OpenAI, Anthropic (Claude), Google Gemini, DeepSeek, Mistral, Ollama (local models), and more.

## Features

- Natural language to SQL conversion powered by any LLM
- Works with OpenAI, Anthropic, Gemini, Ollama, and 10+ other providers
- Automatic database schema introspection with caching
- Smart schema handling for large databases (two-stage table selection)
- Interactive conversation with context (follow-up questions refine queries)
- Read-only query execution (safety enforced at transaction level)
- Editable SQL editor with syntax highlighting
- Results displayed as sortable tables
- Configurable authentication, timeouts, and row limits
- Zero frontend dependencies (self-contained CSS, vanilla JS)

## Installation

Add to your Gemfile:

```ruby
gem "query_lens"
```

Then run:

```bash
bundle install
rails generate query_lens:install
```

This will:
1. Create `config/initializers/query_lens.rb` with RubyLLM and QueryLens configuration
2. Add the engine route to your `config/routes.rb`

## Configuration

Configure your AI provider in `config/initializers/query_lens.rb`:

```ruby
# Configure your AI provider (you only need one)
RubyLLM.configure do |config|
  config.openai_api_key = ENV["OPENAI_API_KEY"]
  # config.anthropic_api_key = ENV["ANTHROPIC_API_KEY"]
  # config.gemini_api_key = ENV["GEMINI_API_KEY"]
  # config.ollama_api_base = "http://localhost:11434"
end

QueryLens.configure do |config|
  # Pick any model supported by your provider
  config.model = "gpt-4o"                          # OpenAI
  # config.model = "claude-sonnet-4-5-20250929"     # Anthropic
  # config.model = "gemini-2.0-flash"               # Google
  # config.model = "llama3.2"                       # Ollama (local)

  config.max_rows = 1000                            # Max rows returned
  config.query_timeout = 30                         # Seconds
  config.excluded_tables = %w[api_keys secrets]     # Hide from AI
  config.authentication = ->(controller) {          # Auth check
    controller.current_user&.admin?
  }

  # Schema cache TTL in seconds (default: 300 / 5 minutes)
  # config.schema_cache_ttl = 300

  # Table selection threshold (default: 50)
  # Schemas larger than this use two-stage AI generation
  # config.table_selection_threshold = 50
end
```

## Usage

Visit `/query_lens` in your browser and start asking questions:

- "How many users signed up this month?"
- "What's the total revenue by plan?"
- "Show me the top 10 accounts by transaction volume"
- "Break that down by month" (follow-up questions work!)

## How Schema Handling Works

QueryLens needs to tell the AI about your database structure so it can write accurate SQL. Naively sending your entire schema on every request would be slow and expensive for large databases. Here's how QueryLens handles this:

### Schema Caching

The database schema is introspected once and cached in memory. Subsequent AI requests reuse the cached schema instead of re-querying every table, column, and row count from the database. The cache expires after 5 minutes by default (configurable via `schema_cache_ttl`).

### Small Databases (< 50 tables)

For most applications, the full schema is compact enough to send directly to the AI in a single request. Every table with its columns, types, foreign keys, and approximate row counts is included in the system prompt. This gives the AI complete context to write accurate queries.

### Large Databases (50+ tables)

For large schemas — hundreds of tables, thousands of columns — sending everything would burn excessive tokens, increase latency, and potentially exceed context windows. QueryLens uses a **two-stage approach** instead:

**Stage 1 — Table Selection:** A compact index is sent to the AI — one line per table listing just the table name, column names, and row count. The AI identifies which tables (typically 3-10) are relevant to the user's question.

**Stage 2 — Query Generation:** The full schema (columns, types, foreign keys, constraints) for only the selected tables is sent to the AI, which generates the SQL query.

This mirrors how a human DBA works: scan the table list, zero in on the relevant ones, then examine their structure. It also mirrors how tools like Claude Code work — they don't load an entire codebase into context, they search for and read only the relevant files.

The threshold is configurable via `table_selection_threshold` (default: 50 tables). For databases right around the threshold, you can tune this based on your preference for completeness vs. speed.

## Security

QueryLens enforces multiple layers of safety:

1. **Read-only transactions**: All queries run inside `SET TRANSACTION READ ONLY` (PostgreSQL)
2. **SQL parsing**: Rejects any statement that isn't a SELECT or WITH (CTE)
3. **Statement blocklist**: Blocks INSERT, UPDATE, DELETE, DROP, ALTER, CREATE, TRUNCATE, GRANT, REVOKE, EXECUTE, CALL
4. **Semicolon blocking**: Prevents multi-statement injection
5. **Function blocklist**: Blocks dangerous PostgreSQL functions (pg_sleep, pg_terminate_backend, etc.)
6. **Query timeout**: Configurable per-query timeout enforced at the database level
7. **Row limits**: Configurable max rows (default 1000)
8. **Authentication**: Configurable auth lambda to restrict access
9. **Table enforcement**: `excluded_tables` blocks both AI context and query execution — queries referencing restricted tables are rejected with a clear error
10. **Audit logging**: Configurable logging of all query executions, blocked attempts, and AI generations

**Important**: Always restrict access to QueryLens in production using the `authentication` config option. Even with read-only enforcement, database access should be limited to authorized users.

### Excluded Tables

Tables listed in `excluded_tables` are enforced at two levels:
- **AI context**: The AI never sees these tables, so it won't suggest queries against them
- **Execution**: Even if a user manually types a query referencing a restricted table, it's blocked with a clear error

Restricted tables are shown in a collapsible banner in the UI so admins know which tables are off-limits.

```ruby
QueryLens.configure do |config|
  config.excluded_tables = %w[api_keys admin_users payment_methods ssn_records]
end
```

### Audit Logging

Every query execution, blocked attempt, and AI generation can be logged. The audit logger receives a hash with `:user`, `:action`, `:sql`, `:row_count`, `:error`, `:timestamp`, and `:ip`.

```ruby
QueryLens.configure do |config|
  # Simple: log to Rails logger
  config.audit_logger = ->(entry) {
    Rails.logger.info("[QueryLens] #{entry[:action]} by #{entry[:user]} — #{entry[:sql]}")
  }

  # Production: log to a database table
  config.audit_logger = ->(entry) {
    QueryAuditLog.create!(
      user_identifier: entry[:user],
      action: entry[:action],
      sql_query: entry[:sql],
      row_count: entry[:row_count],
      error_message: entry[:error],
      ip_address: entry[:ip]
    )
  }

  # The method called on the controller to identify the user (default: :current_user)
  # For Active Admin: :current_admin_user
  config.current_user_method = :current_admin_user
end
```

Actions logged:
- `execute` — successful query execution (includes SQL and row count)
- `execute_blocked` — query rejected by safety checks (includes reason)
- `execute_error` — query failed at database level (includes error message)
- `generate` — AI generated SQL
- `generate_error` — AI generation failed

Audit logging is fail-safe: if your logger raises an error, the query still executes normally and the failure is logged to `Rails.logger.error`.

### Read-Only Connection (Recommended for Production)

For production use, point QueryLens at a read-only database replica or a connection using a read-only PostgreSQL user:

```ruby
QueryLens.configure do |config|
  config.read_only_connection = ActiveRecord::Base.connected_to(role: :reading) {
    ActiveRecord::Base.connection
  }
end
```

## Mounting with Active Admin

If you use [Active Admin](https://activeadmin.info), you can mount QueryLens under your admin path and reuse Active Admin's authentication:

```ruby
# config/routes.rb
Rails.application.routes.draw do
  devise_for :admin_users, ActiveAdmin::Devise.config
  ActiveAdmin.routes(self)

  # Mount QueryLens under /admin/query_lens
  mount QueryLens::Engine, at: "/admin/query_lens"

  # ...
end
```

Then configure QueryLens to require an authenticated admin user:

```ruby
# config/initializers/query_lens.rb
QueryLens.configure do |config|
  config.authentication = ->(controller) {
    # Warden is available because Devise is middleware
    controller.request.env["warden"].authenticated?(:admin_user)
  }
end
```

QueryLens will be available at `/admin/query_lens`. Unauthenticated requests get a 401. Active Admin's navigation won't show a link automatically — you can add one with a custom menu item:

```ruby
# app/admin/query_lens.rb
ActiveAdmin.register_page "QueryLens" do
  menu label: "QueryLens", url: "/admin/query_lens", priority: 99
end
```

## Requirements

- Rails 7.1+
- Ruby 3.1+
- An API key for any [RubyLLM-supported provider](https://rubyllm.com) (or a local Ollama instance)
- PostgreSQL recommended (SQLite works but without transaction-level read-only enforcement)

## Development

```bash
git clone https://github.com/bryanbeshore/query_lens.git
cd query_lens
bundle install
bundle exec rake test
```

## Contributing

1. Fork the repo
2. Create your feature branch (`git checkout -b my-feature`)
3. Commit your changes (`git commit -am 'Add feature'`)
4. Push to the branch (`git push origin my-feature`)
5. Create a Pull Request

## License

MIT License. See [MIT-LICENSE](MIT-LICENSE).
